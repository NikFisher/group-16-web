{"remainingRequest":"/Users/nicholasfisher/group-16-web/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nicholasfisher/group-16-web/client/src/views/Task.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/nicholasfisher/group-16-web/client/src/views/Task.vue","mtime":1571215255122},{"path":"/Users/nicholasfisher/group-16-web/client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/nicholasfisher/group-16-web/client/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { Api } from '@/Api'\n\nexport default {\n  data() {\n    return {\n      player: '',\n      score: 0\n    }\n  },\n  mounted() {\n    this.playGame()\n    this.getPlayer()\n  },\n  methods: {\n    getPlayer() {\n      Api.get('/players/1')\n        .then(response => {\n          this.player = response.data\n        })\n        .catch(error => {\n          this.player = error\n        })\n    },\n    increaseMoney(points) {\n      this.player.currency += points\n      Api.patch('/players/1', this.player)\n        .then(response => {\n          this.player.push(response.data)\n        })\n        .catch(error => {\n          console.log(error)\n        })\n    },\n    playGame() {\n      var canvas, canvasContext\n\n      // Bricks\n      const BRICK_W = 80\n      const BRICK_H = 20\n      const BRICK_GAP = 2\n      const BRICK_COLS = 10\n      const BRICK_ROWS = 14\n      var brickGrid = new Array(BRICK_COLS * BRICK_ROWS)\n      var brickCount = 0\n      var that = this\n\n      // Ball\n      var ballX = 75\n      var ballSpeedX = 8\n      var ballY = 75\n      var ballSpeedY = 8\n\n      // Main Paddle\n      var paddleX = 400\n      const PADDLE_THICKNESS = 15\n      const PADDLE_WIDTH = 100\n      const PADDLE_DIST_FROM_EDGE = 60\n\n      // Mouse\n      var mouseX = 0\n      var mouseY = 0\n\n      /**********\nGeneral GamePlay\n***********/\n      window.onload = function () {\n        canvas = document.getElementById('gameCanvas')\n        canvasContext = canvas.getContext('2d')\n        var framesPerSecond = 30\n        setInterval(updateAll, 1000 / framesPerSecond)\n\n        canvas.addEventListener('mousemove', updateMousePos)\n        brickReset()\n        ballRest()\n      }\n\n      function updateAll() {\n        movement()\n        playArea()\n      }\n\n      function updatePlayer() {\n        that.increaseMoney(1000)\n      }\n\n      function ballRest() {\n        ballX = canvas.width / 2\n        ballY = canvas.height / 2\n      }\n\n      function brickReset() {\n        brickCount = 0\n        var i\n        for (i = 0; i < 3 * BRICK_COLS; i++) {\n          brickGrid[i] = false\n        }\n        for (; i < BRICK_COLS * BRICK_ROWS; i++) {\n          if (Math.random() < 0.5) {\n            brickGrid[i] = true\n          } else {\n            brickGrid[i] = false\n          }\n          brickGrid[i] = true\n          brickCount++\n        }\n      }\n\n      function ballMove() {\n        // ballMovement\n        ballX += ballSpeedX\n        ballY += ballSpeedY\n        // ballY\n        if (ballY > canvas.height) {\n          // ballSpeedY = -ballSpeedY;\n          ballRest()\n          brickReset()\n        } else if (ballY < 0 && ballSpeedY > 0.0) {\n          ballSpeedY = -ballSpeedY\n        }\n        // ballx\n        if (ballX > canvas.width && ballSpeedX > 0.0) {\n          ballSpeedX = -ballSpeedX\n        } else if (ballX < 0 && ballSpeedX < 0.0) {\n          ballSpeedX = -ballSpeedX\n        }\n      }\n\n      function isBrickAtColRow(col, row) {\n        if (col >= 0 && col < BRICK_COLS &&\n      row >= 0 && row < BRICK_ROWS) {\n          var brickIndexUnderCoord = rowColToArrayIndex(col, row)\n          return brickGrid[brickIndexUnderCoord]\n        } else {\n          return false\n        }\n      }\n\n      function ballBrickColl() {\n        var ballBrickCol = Math.floor(ballX / BRICK_W)\n        var ballBrickRow = Math.floor(ballY / BRICK_H)\n        var brickIndexUnderBall = rowColToArrayIndex(ballBrickCol, ballBrickRow)\n        if (ballBrickCol >= 0 && ballBrickCol < BRICK_COLS && ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) {\n          if (isBrickAtColRow(ballBrickCol, ballBrickRow)) {\n            brickGrid[brickIndexUnderBall] = false\n\n            brickCount--\n            updatePlayer()\n            var prevBallX = ballX - ballSpeedX\n            var prevBallY = ballY - ballSpeedY\n            var prevBrickCol = Math.floor(prevBallX / BRICK_W)\n            var prevBrickRow = Math.floor(prevBallY / BRICK_H)\n\n            var bothTestFailed = true\n            if (prevBrickCol != ballBrickCol) {\n              if (isBrickAtColRow(prevBrickCol, ballBrickRow) == false) {\n                ballSpeedX = -ballSpeedX\n                bothTestFailed = false\n              }\n            }\n\n            if (prevBrickRow != ballBrickRow) {\n              if (isBrickAtColRow(ballBrickCol, prevBrickRow) == false) {\n                ballSpeedY = -ballSpeedY\n                bothTestFailed = false\n              }\n            }\n\n            if (bothTestFailed) {\n              ballSpeedX = -ballSpeedX\n              ballSpeedY = -ballSpeedY\n            }\n          }\n        }\n        // colorText(ballBrickCol+\",\"+ballBrickRow+\": \"+brickIndexUnderBall, mouseX, mouseY, 'white');\n      }\n\n      function paddleMove() {\n        // paddle\n        var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE\n        var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS\n        var paddleLeftEdgeX = paddleX\n        var paddleRightEdgeX = paddleX + PADDLE_WIDTH\n        if (ballY > paddleTopEdgeY && // top of paddle\n      ballY < paddleBottomEdgeY && // bottom of paddle\n      ballX > paddleLeftEdgeX && // left half of paddle\n      ballX < paddleRightEdgeX // right half of paddle\n        ) {\n          ballSpeedY = -ballSpeedY\n\n          var paddleCenterX = paddleX + PADDLE_WIDTH / 2\n          var ballDistFromCenterX = ballX - paddleCenterX\n          ballSpeedX = ballDistFromCenterX * 0.35\n\n          if (brickCount == 0) {\n            brickReset()\n          }\n        }\n      }\n\n      function movement() {\n        ballMove()\n        ballBrickColl()\n        paddleMove()\n      }\n\n      function updateMousePos(evt) {\n        var rect = canvas.getBoundingClientRect()\n        var root = document.documentElement\n\n        mouseX = evt.clientX - rect.left - root.scrollLeft\n        mouseY = evt.clientY - rect.top - root.scrollTop\n\n        paddleX = mouseX - PADDLE_WIDTH / 2\n\n        // cheat to test ball in any position\n        // ballX = mouseX;\n        // ballY = mouseY;\n        // ballSpeedY = 4;\n        // ballSpeedY = -4;\n      }\n\n      /**********\nGamePlay Draw functions\n***********/\n      function playArea() {\n        // gameCanvas\n        colorRect(0, 0, canvas.width, canvas.height, 'white')\n        // ball\n        colorCircle()\n        // paddle\n        colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'black')\n\n        drawbricks()\n      }\n\n      function colorRect(leftX, topY, width, height, color) {\n        canvasContext.fillStyle = color\n        canvasContext.fillRect(leftX, topY, width, height)\n      }\n\n      function colorText(showWords, textX, textY, fillColor) {\n        canvasContext.fillStyle = fillColor\n        canvasContext.fillText(showWords, textX, textY)\n      }\n\n      function rowColToArrayIndex(col, row) {\n        return col + BRICK_COLS * row\n      }\n\n      function drawbricks() {\n        for (var eachRow = 0; eachRow < BRICK_ROWS; eachRow++) {\n          for (var eachCol = 0; eachCol < BRICK_COLS; eachCol++) {\n            var arrayIndex = rowColToArrayIndex(eachCol, eachRow)\n            if (brickGrid[arrayIndex]) {\n              colorRect(BRICK_W * eachCol, BRICK_H * eachRow,\n                BRICK_W - BRICK_GAP, BRICK_H - BRICK_GAP, 'green')\n            } //   if brick\n          }// each brick\n        }// each brickrow\n      }// drawbricks\n\n      function colorCircle() {\n        canvasContext.fillStyle = 'black'\n        canvasContext.beginPath()\n        canvasContext.arc(ballX, ballY, 10, 0, Math.PI * 2, true)\n        canvasContext.fill()\n      }\n    }\n  }\n}\n",{"version":3,"sources":["Task.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Task.vue","sourceRoot":"src/views","sourcesContent":["<template>\n<div>\n    <h1>Welcome to the task</h1>\n    <p> DO YOU WANT TO EARN MONEY!?</p>\n    <p> Your current maney is:  {{player.currency}}</p>\n    <body>\n    <div id=\"canvas-container\">\n    <canvas id=\"gameCanvas\" width=\"800\" height=\"600\"></canvas>\n  </div>\n  <div id=\"header-container\">\n  </div>\n</body>\n</div>\n</template>\n\n<script>\nimport { Api } from '@/Api'\n\nexport default {\n  data() {\n    return {\n      player: '',\n      score: 0\n    }\n  },\n  mounted() {\n    this.playGame()\n    this.getPlayer()\n  },\n  methods: {\n    getPlayer() {\n      Api.get('/players/1')\n        .then(response => {\n          this.player = response.data\n        })\n        .catch(error => {\n          this.player = error\n        })\n    },\n    increaseMoney(points) {\n      this.player.currency += points\n      Api.patch('/players/1', this.player)\n        .then(response => {\n          this.player.push(response.data)\n        })\n        .catch(error => {\n          console.log(error)\n        })\n    },\n    playGame() {\n      var canvas, canvasContext\n\n      // Bricks\n      const BRICK_W = 80\n      const BRICK_H = 20\n      const BRICK_GAP = 2\n      const BRICK_COLS = 10\n      const BRICK_ROWS = 14\n      var brickGrid = new Array(BRICK_COLS * BRICK_ROWS)\n      var brickCount = 0\n      var that = this\n\n      // Ball\n      var ballX = 75\n      var ballSpeedX = 8\n      var ballY = 75\n      var ballSpeedY = 8\n\n      // Main Paddle\n      var paddleX = 400\n      const PADDLE_THICKNESS = 15\n      const PADDLE_WIDTH = 100\n      const PADDLE_DIST_FROM_EDGE = 60\n\n      // Mouse\n      var mouseX = 0\n      var mouseY = 0\n\n      /**********\nGeneral GamePlay\n***********/\n      window.onload = function () {\n        canvas = document.getElementById('gameCanvas')\n        canvasContext = canvas.getContext('2d')\n        var framesPerSecond = 30\n        setInterval(updateAll, 1000 / framesPerSecond)\n\n        canvas.addEventListener('mousemove', updateMousePos)\n        brickReset()\n        ballRest()\n      }\n\n      function updateAll() {\n        movement()\n        playArea()\n      }\n\n      function updatePlayer() {\n        that.increaseMoney(1000)\n      }\n\n      function ballRest() {\n        ballX = canvas.width / 2\n        ballY = canvas.height / 2\n      }\n\n      function brickReset() {\n        brickCount = 0\n        var i\n        for (i = 0; i < 3 * BRICK_COLS; i++) {\n          brickGrid[i] = false\n        }\n        for (; i < BRICK_COLS * BRICK_ROWS; i++) {\n          if (Math.random() < 0.5) {\n            brickGrid[i] = true\n          } else {\n            brickGrid[i] = false\n          }\n          brickGrid[i] = true\n          brickCount++\n        }\n      }\n\n      function ballMove() {\n        // ballMovement\n        ballX += ballSpeedX\n        ballY += ballSpeedY\n        // ballY\n        if (ballY > canvas.height) {\n          // ballSpeedY = -ballSpeedY;\n          ballRest()\n          brickReset()\n        } else if (ballY < 0 && ballSpeedY > 0.0) {\n          ballSpeedY = -ballSpeedY\n        }\n        // ballx\n        if (ballX > canvas.width && ballSpeedX > 0.0) {\n          ballSpeedX = -ballSpeedX\n        } else if (ballX < 0 && ballSpeedX < 0.0) {\n          ballSpeedX = -ballSpeedX\n        }\n      }\n\n      function isBrickAtColRow(col, row) {\n        if (col >= 0 && col < BRICK_COLS &&\n      row >= 0 && row < BRICK_ROWS) {\n          var brickIndexUnderCoord = rowColToArrayIndex(col, row)\n          return brickGrid[brickIndexUnderCoord]\n        } else {\n          return false\n        }\n      }\n\n      function ballBrickColl() {\n        var ballBrickCol = Math.floor(ballX / BRICK_W)\n        var ballBrickRow = Math.floor(ballY / BRICK_H)\n        var brickIndexUnderBall = rowColToArrayIndex(ballBrickCol, ballBrickRow)\n        if (ballBrickCol >= 0 && ballBrickCol < BRICK_COLS && ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) {\n          if (isBrickAtColRow(ballBrickCol, ballBrickRow)) {\n            brickGrid[brickIndexUnderBall] = false\n\n            brickCount--\n            updatePlayer()\n            var prevBallX = ballX - ballSpeedX\n            var prevBallY = ballY - ballSpeedY\n            var prevBrickCol = Math.floor(prevBallX / BRICK_W)\n            var prevBrickRow = Math.floor(prevBallY / BRICK_H)\n\n            var bothTestFailed = true\n            if (prevBrickCol != ballBrickCol) {\n              if (isBrickAtColRow(prevBrickCol, ballBrickRow) == false) {\n                ballSpeedX = -ballSpeedX\n                bothTestFailed = false\n              }\n            }\n\n            if (prevBrickRow != ballBrickRow) {\n              if (isBrickAtColRow(ballBrickCol, prevBrickRow) == false) {\n                ballSpeedY = -ballSpeedY\n                bothTestFailed = false\n              }\n            }\n\n            if (bothTestFailed) {\n              ballSpeedX = -ballSpeedX\n              ballSpeedY = -ballSpeedY\n            }\n          }\n        }\n        // colorText(ballBrickCol+\",\"+ballBrickRow+\": \"+brickIndexUnderBall, mouseX, mouseY, 'white');\n      }\n\n      function paddleMove() {\n        // paddle\n        var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE\n        var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS\n        var paddleLeftEdgeX = paddleX\n        var paddleRightEdgeX = paddleX + PADDLE_WIDTH\n        if (ballY > paddleTopEdgeY && // top of paddle\n      ballY < paddleBottomEdgeY && // bottom of paddle\n      ballX > paddleLeftEdgeX && // left half of paddle\n      ballX < paddleRightEdgeX // right half of paddle\n        ) {\n          ballSpeedY = -ballSpeedY\n\n          var paddleCenterX = paddleX + PADDLE_WIDTH / 2\n          var ballDistFromCenterX = ballX - paddleCenterX\n          ballSpeedX = ballDistFromCenterX * 0.35\n\n          if (brickCount == 0) {\n            brickReset()\n          }\n        }\n      }\n\n      function movement() {\n        ballMove()\n        ballBrickColl()\n        paddleMove()\n      }\n\n      function updateMousePos(evt) {\n        var rect = canvas.getBoundingClientRect()\n        var root = document.documentElement\n\n        mouseX = evt.clientX - rect.left - root.scrollLeft\n        mouseY = evt.clientY - rect.top - root.scrollTop\n\n        paddleX = mouseX - PADDLE_WIDTH / 2\n\n        // cheat to test ball in any position\n        // ballX = mouseX;\n        // ballY = mouseY;\n        // ballSpeedY = 4;\n        // ballSpeedY = -4;\n      }\n\n      /**********\nGamePlay Draw functions\n***********/\n      function playArea() {\n        // gameCanvas\n        colorRect(0, 0, canvas.width, canvas.height, 'white')\n        // ball\n        colorCircle()\n        // paddle\n        colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'black')\n\n        drawbricks()\n      }\n\n      function colorRect(leftX, topY, width, height, color) {\n        canvasContext.fillStyle = color\n        canvasContext.fillRect(leftX, topY, width, height)\n      }\n\n      function colorText(showWords, textX, textY, fillColor) {\n        canvasContext.fillStyle = fillColor\n        canvasContext.fillText(showWords, textX, textY)\n      }\n\n      function rowColToArrayIndex(col, row) {\n        return col + BRICK_COLS * row\n      }\n\n      function drawbricks() {\n        for (var eachRow = 0; eachRow < BRICK_ROWS; eachRow++) {\n          for (var eachCol = 0; eachCol < BRICK_COLS; eachCol++) {\n            var arrayIndex = rowColToArrayIndex(eachCol, eachRow)\n            if (brickGrid[arrayIndex]) {\n              colorRect(BRICK_W * eachCol, BRICK_H * eachRow,\n                BRICK_W - BRICK_GAP, BRICK_H - BRICK_GAP, 'green')\n            } //   if brick\n          }// each brick\n        }// each brickrow\n      }// drawbricks\n\n      function colorCircle() {\n        canvasContext.fillStyle = 'black'\n        canvasContext.beginPath()\n        canvasContext.arc(ballX, ballY, 10, 0, Math.PI * 2, true)\n        canvasContext.fill()\n      }\n    }\n  }\n}\n</script>\n<style>\nbody{\nbackground-color: black;\n}\n#canvas-container{\n  text-align: center;\n}\n\n#header-container{\n  text-align: center;\n  font-size: 40px;\ncolor: white;\n}\n</style>\n"]}]}